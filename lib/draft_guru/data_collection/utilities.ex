defmodule DraftGuru.DataCollection.Utilities do
  @moduledoc """
  This module is for helper functions that don't merit
  inclusion in another module.  Mostly for string formatting,
  date math, and file manipulation
  """

  @spec format_timestamp() :: binary()
  def format_timestamp do

    NaiveDateTime.utc_now()
    |> NaiveDateTime.to_string()
    |> String.replace(":", "")
    |> String.replace(" ", "_")
    |> String.replace("-", "_")
    |> String.replace(".", "_")
  end

  @doc """
  Creates a unique filename using a base name and an optional file suffix.

  This function combines the provided base name with a timestamp generated by
  `format_timestamp/0` and appends the specified file suffix (defaults to ".csv").

  If an invalid suffix is provided, it will fallback to using ".csv" and log a warning.

  ## Parameters
    * `base_name` - The prefix for the filename (should be a string)
    * `file_suffix` - The file extension to append (defaults to ".csv")

  ## Returns
    A string in the format: "base_name_TIMESTAMP.extension"
  """
  @spec create_filename(String.t(), binary()) :: nonempty_binary()
  def create_filename(base_name, file_suffix \\ ".csv") do
    allowed_extensions = [".png", ".jpg", ".jpeg", ".csv", ".json", ".txt"]

    actual_suffix =
      if file_suffix in allowed_extensions do
        file_suffix
      else
        # Log a warning instead of raising an error
        require Logger
        Logger.warning("Invalid file suffix '#{file_suffix}'. Using '.csv' instead. " <>
          "Allowed extensions: #{Enum.join(allowed_extensions, ", ")}")
        ".csv"  # Default to .csv if invalid extension
      end

    timestamp = format_timestamp()
    "#{base_name}_#{timestamp}#{actual_suffix}"
  end

  @doc """
  Creates a unique filename using a base name and an optional file suffix.
  Returns {:ok, filename} or {:error, reason}.

  See create_filename/2 for legacy direct string return.
  """
  @spec create_filename_safe(String.t(), binary()) :: {:ok, binary()} | {:error, binary()}
  def create_filename_safe(base_name, file_suffix \\ ".csv") do
    allowed_extensions = [".png", ".jpg", ".jpeg", ".csv", ".json"]

    if file_suffix in allowed_extensions do
      timestamp = format_timestamp()
      {:ok, "#{base_name}_#{timestamp}#{file_suffix}"}
    else
      {:error, "File suffix must be one of: #{Enum.join(allowed_extensions, ", ")}"}
    end
  end

  @doc """
  Converts a list of maps to a CSV file.

  * `list_of_maps` is a list of maps (each map is a row).
  * The CSV headers are taken from all unique keys in the maps.
  * If a map is missing a key that is in the headers, its value is taken as `""`.

  ## Example

      iex> list_of_maps = [
      ...>   %{name: "Alice", age: 30, city: "NY"},
      ...>   %{name: "Bob", city: "LA"}
      ...> ]
      iex> MapsToCSV.write_to_csv(list_of_maps, "people.csv")

  Creates a file "people.csv" with headers: name,age,city
  and rows filled in accordingly.
  """
  def export_data_to_file(tuple_of_maps, combine_section,
                          directory_path \\ "lib/draft_guru/data_collection/data_files") do
    # Collect all unique keys across all maps to form the CSV headers
    {:ok, list_of_maps} = tuple_of_maps
    headers =
      list_of_maps
      |> Enum.flat_map(&Map.keys/1)
      |> Enum.uniq()

    # Prepare the CSV lines:
    # 1) A header line (joined by commas)
    # 2) A line for each map (matching headers in the same order)
    csv_lines =
      [
        Enum.join(headers, ",")  # header row
        | Enum.map(list_of_maps, fn row_map ->
            headers
            |> Enum.map(fn key -> Map.get(row_map, key, "") end)
            |> Enum.join(",")
          end)
      ]
      |> Enum.join("\n")

    # create the filepath
    file_name = create_filename(combine_section)
    full_file_path = Path.join(directory_path, file_name)

    # Write the CSV string to the file
    File.write!(full_file_path, csv_lines)
  end

  @doc """
  Function to take whole string name from data and
  split into its associated first name, middle initial, last name, etc
  """
  def split_name_into_parts(name_string) do
    split_name = String.split(name_string)

    name_suffixes = [
      "ii", "iii", "iv", "jr", "sr", "junior", "senior",
    ]

    case split_name do
      [first, middle, last, suffix] ->
        %{first_name: first, middle_name: middle, last_name: last, suffix: suffix}

      [first, last] ->
        %{first_name: first, middle_name: nil, last_name: last, suffix: nil}

      [first] ->
        %{first_name: first, middle_name: nil, last_name: nil, suffix: nil}

      [first, middle, last] ->
        if sanitize(last) in name_suffixes do
          %{first_name: first, middle_name: nil, last_name: middle, suffix: last}

        else
          %{first_name: first, middle_name: middle, last_name: last, suffix: nil}
        end
    end

  end

  def sanitize(string) do
    string
    |> String.downcase()
    |> String.trim()
    |> String.replace(~r/[^[:alnum:]\s'\-]+/u, "")
  end

  def clean_map_value(value) do

    case parse_null_value(value) do
      nil -> nil
      not_nil_value -> parse_non_null_value(not_nil_value)
    end
  end

  @doc false
  defp parse_null_value("-%"), do: nil
  defp parse_null_value("_"), do: nil
  defp parse_null_value(""), do: nil
  defp parse_null_value("nil"), do: nil
  defp parse_null_value("-"), do: nil
  defp parse_null_value(nil), do: nil
  defp parse_null_value(value), do: value

  @height_regex ~r/^(?<ft>\d+)'[\s]*(?<in>\d+(?:\.\d+)?)(?:''|"{1,2})?$/

  def parse_non_null_value(value) do
    result = cond do
      # 1. Check if it's a string that matches the height format
      is_binary(value) and Regex.match?(@height_regex, value) ->
        case Regex.named_captures(@height_regex, value) do
          %{"ft" => ft_str, "in" => in_str} ->
            try do
              ft = String.to_integer(ft_str)
              inch = parse_float_safely(in_str)
              {:ok, ft * 12 + inch}
            rescue
              _ -> {:error, "Invalid height numbers: #{value}"}
            end
          _ ->
             {:error, "Failed to capture height parts: #{value}"}
        end

      # 2. Handle if the value is already a float
      is_float(value) ->
        {:ok, value}

      # 3. Handle if the value is already an integer
      is_integer(value) ->
        {:ok, value}

      # 4. Handle other string values (try numeric conversion)
      is_binary(value) ->
        try_parse_string(value)

      # 5. Handle nil
      is_nil(value) ->
        {:ok, nil}

      # 6. Fallback for any other unexpected types
      true ->
        {:error, "Unhandled value type: #{inspect(value)}"}
    end

    handle_parse_result(result)
  end

  # Handle string parsing attempts
  defp try_parse_string(value) do
    case Float.parse(value) do
      {float, ""} -> {:ok, float}
      {float, _rest} -> {:ok, float}  # Be lenient about trailing chars
      :error ->
        case Integer.parse(value) do
          {int, ""} -> {:ok, int}
          {int, _rest} -> {:ok, int}  # Be lenient about trailing chars
          :error -> {:ok, value}  # Keep as string if parsing fails
        end
    end
  end

  # Helper to safely parse float values with integer fallback
  defp parse_float_safely(str) do
    case Float.parse(str) do
      {float, _} -> float
      :error ->
        case Integer.parse(str) do
          {int, _} -> int * 1.0
          :error -> 0.0  # Default to 0 if all parsing fails
        end
    end
  end

  # Helper to manage the {:ok, value} / {:error, reason} tuple
  defp handle_parse_result({:ok, value}), do: value
  defp handle_parse_result({:error, reason}) do
    # Log the error but don't halt the process
    IO.puts("Utilities.parse_non_null_value: #{reason}")
    nil  # Return nil for invalid values
  end

  def parse_draft_year(nil), do: "unknown"
  def parse_draft_year(year) when is_integer(year), do: year
  def parse_draft_year(year) when is_float(year), do: trunc(year)
  def parse_draft_year(year) when is_binary(year) do
    case Integer.parse(year) do
      {int, _} -> Integer.to_string(int)
      :error -> "invalid"
    end
  end
end
